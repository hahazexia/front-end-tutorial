# 域名系统（DNS）

> 域名系统是一个分层分布命名系统，负责为计算机，服务或者任何连接到因特网和私人网络的资源提供命名。它通过域名分配到参与的网络实体联合了各种各样的信息。更重要的是，它会将域名翻译，使人们可以轻松记住网站的地址，而不是数字形式的IP地址。域名系统是大多数因特网服务的关键功能性组件，因为它是因特网首要的目录服务。[以上解释引用自维基百科](https://en.wikipedia.org/wiki/Domain_Name_System)

## 域名是什么？

域名（Domain names），其实就是网站的网址。电脑可以理解的网址的格式是下面这样的：

```
173.194.121.32
```

又或者是这样的：

```
2027:0da8:8b73:0000:0000:8a2e:0370:1337
```

这些由数字或是数字和字母组成的地址，对于计算机来说很容易理解和处理，但是对人来说，很难记住，于是域名系统应运而生。

有了域名系统，网址就变成了下面的样子：

```
developer.mozilla.org
www.baidu.com
```
因为有了域名，网址可以变成具体的名字，容易识别和记忆。

## 域名的结构

一个域名由一个或多个部分组成，技术上讲叫做**标签**，多个标签惯例上由点号连接和分隔，例如`example.com`。

<p align="center">
  <img alt="域名结构1" src="../img/DNS1.png">
</p>
<p align="center"><span>域名结构1</span></p>

如上图所示，域名是从后往前看的，最后一个部分，`.org`被称作 **Top-level domains**，汉语意思为**顶级域名**。

然后往左，是第一个标签，再往左是第二个标签。

通常紧挨着顶级域名的第一个标签也被叫做**二级域名** （Second-level damains）。

所以依次类推就是下面这张图：

<p align="center">
  <img alt="域名结构2" src="../img/DNS2.png">
</p>
<p align="center"><span>域名结构2</span></p>

如上图所示，从顶级域名往左，每隔一个点就会降一个层次，分别为二级，三级，以此类推。

也就是说左边的低级别域是右边的子域。例如，对于`example.com`中，`example`域是`com`域的子域。

### 顶级域名

类似 .com .net .org 这样的域名被称为顶级域名，一个域名会以一个顶级域名作为结尾。

顶级域名一般有两种，一种是**通用顶级域**，一种是**国家和地区顶级域**。

举例如下：

```
通用顶级域

.gov 政府网站
.edu 学校和教育相关网站
.com 商业，注册量最大最通用的域名
.org 非营利组织
.net 网络，被定位为网络基础服务提供商
.int 国际组织

国家顶级域

.cn 中国
.us 美国
.uk 英国

```

### 二级和低级别域名（或者说子域名）

上面已经说过，紧挨着顶级域名的就是二级域名，再往左就是三级域名，然后是四级域名，等等以此类推。

一般有多少级域名是没有限制的，一个网址可以有四级域名，例如：`sos.state.oh.us`。

一般二级域名的名字都是公司的名字，或者产品和服务的名字，例如：`www.baidu.com`。

而下一级域名一般被用来指定主机服务器，比如`www.baidu.com`中的`www`指明了是万维网服务器，`ftp.example.com`中的`ftp`指明了是FTP服务器，`mail.example.com`中的`mail`指明了是电子邮件服务器。

## IP 地址

IP 地址是我们称之为可访问的网络地址。每一个 IP 地址必须是独一无二的。

IPv4 是最普遍的 IP 地址形式，它由4组0 ~ 255数字组成，彼此用点号分隔。例如下面：

```
111.222.111.222
```

IPv6 地址是最新的 IP 地址形式，它由8组4位的16进制数字组成，彼此用分号分隔。例如下面：

```
2001:0DB8:02de:0000:0000:0000:0000:0e13
```

有了 DNS，就可以通过域名找到对应的 IP 地址来访问网站。

## 域名服务器

一个被用来将域名翻译成对应的 IP 地址的服务器就是域名服务器。这些服务器在 DNS 系统中做了大部分的工作。当大量的域名翻译工作对一台服务器来说任务量太重的时候，就拆分出很多台服务器，每一台服务器负责不同的子域名，这样减轻了一台服务器的工作量。

## DNS 如何工作？

前面解释了一些涉及 DNS 系统的术语，但是 DNS 到底是如何工作的？

从很高级别的角度来看这个系统会觉得很简单，但是深入细节后其实很复杂。

### 根服务器（Root Servers）

就像之前说的，DNS 是一个分层的系统。这个系统的最高处就是根服务器。这些服务器被不同的机构控制并且被 ICANN 委派权限。（ICANN，互联网名称与数字地址分配机构）

目前正在运转的根服务器一共有13台。然而，每一分钟都有巨大数量的域名需要被解析，这其中处理请求的每一台服务器其实都是镜像。有趣的事情是每一台根服务器的镜像服务器都与之分享相同的 IP 地址。当向某个确定的根服务器的请求被接受到时，请求会被转向最近的镜像服务器。

这些根服务器是做什么用的？根服务器用来处理有关获取**顶级域名**（Top-level domains）信息的请求。所以当一个请求获取的信息是低级别域名服务器无法解析的，紧接着就会去查询根服务器。

根服务器实际上不知道域在哪里托管。但是，它们将能够将请求者引导到处理特定请求的顶级域的域名服务器。

所以当一个请求`www.wikipedia.org`发向根服务器的时候，根服务器并不会找到最终的地址。它会检查域文件（zone files）中匹配`www.wikipedia.org`这个网站的一个列表，而不是仅仅查找到一个匹配项。

它会查找到负责`org`这个顶级域的域名服务器的地址然后告诉请求实体跳转过去。

### TLD服务器（顶级域服务器）

然后请求者会发送一个新的请求到这个 IP 地址（根服务器返回的地址），这个地址是负责对应的顶级域的服务器。

继续我们的例子，一个请求发送到知道`org`顶级域的服务器，看看它是否知道`www.wikipedia.org`的位置。

服务器再一次查找服务器中的域文件（zone files）。

最后在文件中会找到一个记录，这个记录列出了负责`wikipedia.org`的域名服务器。这个查询结果离我们想要的答案接近了。

### 域级域名服务器（Domain-Level Name Servers）

此刻，请求者知道了负责`wilipidia.org`真实 IP 地址的域名服务器的 IP 地址。接着就再次发送一个新的请求到这个域名服务器。

服务器查找它的域文件（zone files），在其中找到了一个与`wikipedia.org`网站想联系的文件，在这个文件中，有一条关于`www`主机的记录。这一条记录会告知这个主机真实的 IP 地址。然后域名服务器将真实地址返回给请求者。

上面的一系列过程至此，走通了一遍 DNS 的处理流程。

### 什么是解析域名服务器（Resolving Name Server）？

在上面的场景中，我们提到了“请求者”。在这样的情况下谁是请求者？

几乎在所有情况下，这个请求者就是我们在此处说的“解析域名服务器”。一个解析域名服务器是专门用来向其他服务器提问的服务器。它基本上作为一个中间人在用户和其他服务器之间，缓存了用户之前的查询结果，这样可以提高访问速度，它还知道哪些根服务器可以帮助解析请求。

总的来说，一个用户将会有好几个配置好的解析域名服务器。这些解析域名服务器通常由 ISP 提供（互联网服务提供商）。例如谷歌提供了解析 DNS 的服务器供用户查询信息。你可以在你的电脑上手工配置。

当你在浏览器地址栏中输入一个 URL 后，计算机首先会去看是否有现成的对应的地址。它会查找系统的“hosts”文件以及其他几个地方。然后发送请求给解析域名服务器然后等待服务器返回网站的真实 IP 地址。

解析域名服务器先会去检查缓存。如果缓存中没有，就会执行我们上面讲过的 DNS 的流程。

解析域名服务器帮助用户做了很多工作，所以客户端这边只需要向它发出请求然后等待最终结果就行了。

### 域文件（zone files）

上面的 DNS 工作流程中我们提到了一个概念：域文件（zone files）。

域文件里存储着域名服务器所知道的关于域名的信息。域名服务器知道的域名信息都会存储在域文件中。大多数发送到普通域名服务器的请求都会跳转，因为服务器没有对应的域文件。

一个域名服务器的域文件越多，它能够答复的请求就越多，并且越可信。

**一个域文件通常只包含一个单独的域的信息。它保存的信息是资源地址的多条记录。**

域文件的参数 $ORIGIN 是一个默认情况下这个域的最高级别依据。

所以如果一个域文件被用作配置`example.com`域名，它的 $ORIGIN 就会被设置为`example.com.`。

这个要么被设置在域文件的最顶层，要么被定义在 DNS 服务器的配置文件中来标记域文件。无论什么方式，这个参数都用来描述一个域对什么具有权威性。

类似的，$TTL 配置了提供的信息“存活的时间”。它就是一个定时器。一个缓存域名服务器会使用上一次查询结果来响应请求直到 $TTL 时间过去。
